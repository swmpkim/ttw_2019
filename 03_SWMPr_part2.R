library(SWMPr)
library(lubridate)


## SWMPr can do some other things too:

## aggregate data by a specified time period ----

# what if we want monthly averages?
avgs <- aggreswmp(bhwq_qaqc, by = "months")
head(avgs)


# the default argument is average
# notice it looks like each month is represented by the first day of it
# that's because R doesn't handle year-month alone very well

# what if we want min?
mins <- aggreswmp(bhwq_qaqc, by = "months", FUN = min)
head(mins)


## remember na.rm = TRUE? Here, we just add it with a comma
mins2 <- aggreswmp(bhwq_qaqc, by = "months", FUN = min, na.rm = TRUE)
head(mins2)



## you can also select one (or more) parameters:
mins3 <- aggreswmp(bhwq_qaqc, by = "months", params = c("temp", "sal"),
                   FUN = min, na.rm = TRUE)
head(mins3)



## know when this is really helpful?
## using the sum() function to calculate daily rainfall

# read in met data (Grand Bay's is gndcrmet; 
# you can use your own data if you'd like)
# what function do we use???
# check out the trace = TRUE option:
met_data <- -------(data_path, "gndcrmet", trace = TRUE)

met_qc <- qaqc(met_data, qaqc_keep = c(0, 1, 4, 5))

names(met_qc)  # remind ourselves of the column names

daily_rain <- aggreswmp(met_qc, by = "days", params = "totprcp",
                        FUN = sum)
head(daily_rain)

# how would we find maximum daily rainfall over this time period?
-----(---$---)


# how do we find the date on which that happened?
## subsetting ----

# we can use square brackets to subset data
# [rows, columns]   or  [x, y]
met_qc[1, ]   # selects the first row; all columns
met_qc[ , 1]  # selects the all rows; first column

# note: the above line gives the same results as:
met_qc$datetimestamp
# but we don't have to know the name of the column
# each method of column selection is useful; which to use 
# depends on the situation



# what will this give us?
met_qc[1, 1]

# another way to get that is:
met_qc$datetimestamp[1]    
# because we've specified the column with the $,
# we only have to account for rows inside the square brackets


# to specify multiple rows or columns,
# make a sequence using a :
met_qc[1:6, ]

# does that output look familiar?


## back to the problem of finding which date had the maximum daily rainfall

# we can calculate the max
max(daily_rain$totprcp, na.rm = TRUE)

# and a function called which.max can tell us which row that occurs on:
which.max(daily_rain$totprcp)


# so we need to use the row number generated by which.max
# to subset the data frame:

# daily_rain[ conditon-here , ]   

daily_rain[which.max(daily_rain$totprcp), ]




# if all we really want is the date, and we don't care about the total,
# we can subset this way:
daily_rain[which.max(daily_rain$totprcp), 1]

# or
daily_rain[which.max(daily_rain$totprcp), "datetimestamp"]

# or
daily_rain$datetimestamp[which.max(daily_rain$totprcp)]  ## no comma here


### you do NOT have to memorize all these different ways to subset
# but you should be aware that they exist




### Challenge ----

## part 1:
# make a data frame called weekly_rain
# and calculate total rainfall on that basis
# remember to use ?aggreswmp

weekly_rain <- aggreswmp(met_qc, by = "----", ---- = "totprcp", FUN = ----)

# what is the highest weekly rainfall amount, and when did it occur?


### potential application:

## what if we want to subset the met_qc data frame 
## to only that day of max rainfall


## first problem:
# datetimestamp gives us more than just a date

## solution: make a new column, using the as.Date function
met_qc$date <- as.Date(met_qc$datetimestamp)


# now to subset.
# it is very similar, but includes some extra notation because
# we have to get very specific.

# we want the ROWS of met_qc
# where the date column matches
# the datetimestamp identified as max rain in the daily_rain data frame

rainiest_day <- met_qc[met_qc$date == daily_rain$datetimestamp[which.max(daily_rain$totprcp)], ]

## if that's too crazy, you can assign that date to a variable
date_i_want <- daily_rain$datetimestamp[which.max(daily_rain$totprcp)]

rainiest_day <- met_qc[met_qc$date == date_i_want, ]    # much more readable

## we could subset one of our water quality data frames the same way
## (after making a date column, of course)

# the dplyr package has easier ways to subset
# we will get to that later   


##### let's review a bit
##### functions we've covered so far:

### importing data
# read.csv()
# SWMPr::import_local()



### examining data
# names(), head(), tail(), ncol(), nrow(), dim()
# str()
# class()
# plot()



### modifying data
# SWMPr::qaqc
# as.Date
# as.POSIXct
# lubridate::mdy_hm() and friends




### summarizing data
# mean(), min(), max(); na.rm = TRUE
# summary()
# SWMPr::aggreswmp()



### subsetting data
#  $ for columns
#  [rows, columns]






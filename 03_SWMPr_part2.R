library(SWMPr)
library(lubridate)
library(dplyr)

### so far we have used SWMPr for:
# importing multiple data files from a station with import_local()
# selecting which values to keep based on QAQC flags and codes with qaqc()


## if you restarted R, re-read and qc the data
# this is also a good place to talk about commenting and uncommenting code

# data_path <- "data/AQS_zip"
# bhwq <- import_local(data_path, "gndbhwq", trace = TRUE)
# bhwq_qaqc <- qaqc(bhwq)



## SWMPr can do more than just read and qc data



## first, a bit of cleanup ----
## get rid of these columns that are full of NAs
## (because they're parameters that aren't reported)
# as with everything else in R, there are multiple ways to do this

# one way: turn a column into "NULL":
bhwq_qaqc$level <- NULL
head(bhwq_qaqc)


# there are other functions for subsetting
# especially 'select' from dplyr
# but we want these to stay as 'swmpr' objects
# and SWMPr has a subset function too:
?subset.swmpr

bhwq_qaqc <- subset(bhwq_qaqc, rem_cols = TRUE)


head(bhwq_qaqc)





## aggregate data by a specified time period ----

# what if we want monthly averages?
avgs <- aggreswmp(bhwq_qaqc, by = "months")
head(avgs)



# the default argument for aggreswmp is mean, with na.rm = TRUE
# notice it looks like each month is represented by the first day of it
# that's because R doesn't handle year-month alone very well

# what if we want min?
mins <- aggreswmp(bhwq_qaqc, by = "months", FUN = min)
head(mins)




## remember na.rm = TRUE? Here, we just add it with a comma
mins2 <- aggreswmp(bhwq_qaqc, by = "months", FUN = min, na.rm = TRUE)
head(mins2)




## you can also select one (or more) parameters:
mins3 <- aggreswmp(bhwq_qaqc, by = "months", params = c("temp", "sal"),
                   FUN = min, na.rm = TRUE)
head(mins3)



## know when this is really helpful?
## using the sum() function to calculate daily rainfall

# import met data (Grand Bay's is gndcrmet; 
# you can use your own data if you'd like)

# what function do we use???
met_data <- -------(data_path, "gndcrmet", trace = TRUE)


# run the qaqc step
met_qc <- qaqc(met_data, qaqc_keep = c(0, 1, 4, 5))

# remind ourselves what the names look like
names(met_qc)  

# use aggreswmp() to get daily rain totals
# put it into an object called "daily_rain"
daily_rain <- aggreswmp(met_qc, by = "days", params = "totprcp",
                        FUN = sum, na.rm = TRUE)
# use na.rm = TRUE with this function like you would with mean, max, and min
head(daily_rain)


#### how would we find maximum daily rainfall over this time period?
-----(---$---)


# how do we find the date on which that happened?
## subsetting ----

# remember the square brackets that helped us
# select parts of a vector?
# we can use those to subset data frames too
# [rows, columns]   or  [x, y]
met_qc[1, ]   






# [1, ] selects the first row; all columns





met_qc[ , 1]  






# selects all rows; first column


# note: the above line gives the same results as:
met_qc$datetimestamp

# but we don't have to know the name of the column
# each method of column selection is useful; which to use 
# depends on the situation



# what will this give us?
met_qc[1, 1]






# another way to get that is:
met_qc$datetimestamp[1]    


# because we've specified the column with the $,
# we only have to account for rows inside the square brackets




# to specify multiple rows or columns,
# make a sequence using a :
met_qc[1:6, ]

# does that output look familiar?



## back to the problem of finding which date had the maximum daily rainfall

# first, we can calculate the max
max(daily_rain$totprcp, na.rm = TRUE)

# a function called which.max() can tell us which row that occurs on:
which.max(daily_rain$totprcp)


# so we need to use the row number generated by which.max()
# to subset the data frame

# to make the steps seem simpler,
# we can assign the row of the max to its own object
row_index <- which.max(daily_rain$totprcp)

row_index


daily_rain[row_index, ]





### Challenge ----

## part 1:
# make a data frame called weekly_rain
# and calculate total rainfall on that basis
# remember to use ?aggreswmp

weekly_rain <- aggreswmp(met_qc, by = "----", ---- = "totprcp", 
                         FUN = ----, na.rm = TRUE)

## part 2:
# what is the highest weekly rainfall amount, and when did it occur?
# just pull out the row of the data frame

# first, find where it happens:
row_index <- ------.max(weekly_rain$totprcp)
# next, pull out that row:
----[ row_index, ]



## A little bit more information
# typically, you might want all of the rows where some parameter value
# exceeds (or is equal to, or less than) a certain amount

# you can do that with square brackets, but there is also an easier way using
# the dplyr package

# first, we'll use square brackets to pull out any weeks where rainfall was >100
weekly_rain[weekly_rain$totprcp > 100 , ]


## the dplyr package makes subsetting a little easier:
# select() lets you choose columns
# and filter() lets you choose rows

# so to do the same thing as above, we would type:
filter(weekly_rain, totprcp > 100)


# another equivalent is:
weekly_rain %>%
        filter(totprcp > 100)


# %>% is called the pipe operator
# you read it as "and then"
# it takes output from the step before it and feeds it right into the next step
# so you don't have to specify the object every time
# this is really useful when you want to do more than one thing;
# e.g. subset the met_qc data frame to only include wind speed and wind direction
# when wind speed is > 15 m/s

met_qc %>%
        select(wspd, wdir) %>%
        filter(wspd > 15)

# your resulting data frame won't work quite right with SWMPr functions


# while we're talking about dplyr, the other super useful functions are
# group_by() and summarize()
# they give similar info as aggreswmp, but are useful on other datasets


# first create a "year" column in the dataset
met_qc_dplyr <- met_qc %>%
        mutate(year = lubridate::year(datetimestamp)) %>%
        select(-totsorad)
head(met_qc_dplyr)

# now, group by year and calculate summary statistics
met_qc_dplyr %>%
        group_by(year) %>%
        summarize(temp_min = min(atemp, na.rm = TRUE),
                  temp_max = max(atemp, na.rm = TRUE),
                  wspd_min = min(wspd, na.rm = TRUE),
                  wspd_max = max(wspd, na.rm = TRUE))

# again, this won't be a SWMPr object


##### let's review a bit
##### functions we've covered so far:

### importing data
# read.csv()
# SWMPr::import_local()
# -- something we haven't gone over yet: 
# -- SWMPrExtension::import_local_nut() lets you choose between 
# -- grab and diel sample types



### examining data
# names(), head(), tail(), ncol(), nrow(), dim()
# str()
# class()
# plot()
# ggplot2::ggplot()



### modifying data
# SWMPr::qaqc
# as.Date
# as.POSIXct
# lubridate::mdy_hm() and friends
# dplyr::mutate()




### summarizing data
# mean(), min(), max(); na.rm = TRUE
# summary()
# SWMPr::aggreswmp()
# dplyr::group_by() and summarize()



### subsetting data
#  $ for columns
#  [rows, columns]
#  dplyr::select() for columns
#  dplyr::filter() for rows





